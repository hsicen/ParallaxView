package com.hsicen.parallaxviewimport android.annotation.SuppressLintimport android.content.Contextimport android.graphics.Rectimport android.os.Buildimport android.util.AttributeSetimport android.view.MotionEventimport android.view.Viewimport android.view.ViewGroupimport android.view.ViewGroup.LayoutParams.MATCH_PARENTimport android.view.ViewGroup.LayoutParams.WRAP_CONTENTimport android.view.animation.LinearInterpolatorimport androidx.appcompat.widget.LinearLayoutCompatimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.LifecycleEventObserverimport androidx.lifecycle.LifecycleOwnerimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport java.lang.ref.WeakReferenceclass ParallaxView @JvmOverloads constructor(  context: Context,  attrs: AttributeSet? = null,  defStyleAttr: Int = 0) : LinearLayoutCompat(context, attrs, defStyleAttr), LifecycleEventObserver {  companion object {    private const val MAX_COUNT = 10000    private const val RV_COUNT = 2    private const val LOOP_TIME = 1000L    private const val SCROLL_TIME = 1200    private const val SCROLL_DISTANCE = 100  }  private lateinit var mConfig: ParallaxViewConfig  private val mData = ArrayList<ParallaxData>()  private val mLoopTask = AutoLoopTask(this)  private var isLoop = false  private val mInterpolator by lazy { LinearInterpolator() }  private val mScrollListeners = arrayOfNulls<RecyclerView.OnScrollListener>(RV_COUNT)  private val mDecoration by lazy {    object : RecyclerView.ItemDecoration() {      val margin = mConfig.itemMargin      override fun getItemOffsets(        outRect: Rect,        view: View,        parent: RecyclerView,        state: RecyclerView.State      ) {        super.getItemOffsets(outRect, view, parent, state)        val manager = parent.layoutManager ?: return        val rlp = (view.layoutParams as? RecyclerView.LayoutParams) ?: return        val position = rlp.viewLayoutPosition        val count = manager.itemCount        if (position == RecyclerView.NO_POSITION || 0 == count) return        outRect[margin, margin, margin] = margin      }    }  }  private val mAdapter1 by lazy {    object : RecyclerView.Adapter<ParallaxViewHolder>() {      override fun getItemCount(): Int = mData.size * MAX_COUNT      override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ParallaxViewHolder {        return mConfig.parallaxAdapter.onCreateViewHolder(parent, viewType)      }      override fun onBindViewHolder(holder: ParallaxViewHolder, position: Int) {        val pos = position * 2        val item = mData[pos % mData.size]        mConfig.parallaxAdapter.onBindViewHolder(holder, pos, item)        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {          holder.root.tooltipText = "$pos"        }      }      override fun onViewAttachedToWindow(holder: ParallaxViewHolder) {        super.onViewAttachedToWindow(holder)        if (holder.layoutPosition == RecyclerView.NO_POSITION) return        val pos = (holder.layoutPosition * 2) % mData.size        mData.getOrNull(pos)?.let { item ->          mConfig.parallaxAdapter.onAttachedToWindow(holder, pos, item)        }      }      override fun onViewDetachedFromWindow(holder: ParallaxViewHolder) {        super.onViewDetachedFromWindow(holder)        if (holder.layoutPosition == RecyclerView.NO_POSITION) return        val pos = (holder.layoutPosition * 2) % mData.size        mData.getOrNull(pos)?.let { item ->          mConfig.parallaxAdapter.onDetachedFromWindow(holder, pos, item)        }      }    }  }  private val mAdapter2 by lazy {    object : RecyclerView.Adapter<ParallaxViewHolder>() {      override fun getItemCount(): Int = mData.size * MAX_COUNT      override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ParallaxViewHolder {        return mConfig.parallaxAdapter.onCreateViewHolder(parent, viewType)      }      override fun onBindViewHolder(holder: ParallaxViewHolder, position: Int) {        val pos = position * 2 + 1        val item = mData[pos % mData.size]        mConfig.parallaxAdapter.onBindViewHolder(holder, pos, item)        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {          holder.root.tooltipText = "$pos"        }      }      override fun onViewAttachedToWindow(holder: ParallaxViewHolder) {        super.onViewAttachedToWindow(holder)        if (holder.layoutPosition == RecyclerView.NO_POSITION) return        val pos = (holder.layoutPosition * 2 + 1) % mData.size        mData.getOrNull(pos)?.let { item ->          mConfig.parallaxAdapter.onAttachedToWindow(holder, pos, item)        }      }      override fun onViewDetachedFromWindow(holder: ParallaxViewHolder) {        super.onViewDetachedFromWindow(holder)        if (holder.layoutPosition == RecyclerView.NO_POSITION) return        val pos = (holder.layoutPosition * 2 + 1) % mData.size        mData.getOrNull(pos)?.let { item ->          mConfig.parallaxAdapter.onDetachedFromWindow(holder, pos, item)        }      }    }  }  private val mRv1 by lazy {    RecyclerView(context).apply {      adapter = mAdapter1      setHasFixedSize(true)      itemAnimator = null      isNestedScrollingEnabled = true      layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, WRAP_CONTENT)      layoutManager = LinearLayoutManager(context, RecyclerView.HORIZONTAL, false)      addItemDecoration(mDecoration)      mScrollListeners[0]?.let { addOnScrollListener(it) }    }  }  private val mRv2 by lazy {    RecyclerView(context).apply {      adapter = mAdapter2      setHasFixedSize(true)      itemAnimator = null      isNestedScrollingEnabled = true      layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, WRAP_CONTENT)      layoutManager = LinearLayoutManager(context, RecyclerView.HORIZONTAL, false)      addItemDecoration(mDecoration)      mScrollListeners[1]?.let { addOnScrollListener(it) }    }  }  @SuppressLint("NotifyDataSetChanged")  fun updateData(list: List<ParallaxData>, force: Boolean = false) {    fun setNewInstance(list: List<ParallaxData>) {      if (::mConfig.isInitialized.not()) return      if (list == mData) return      mData.clear()      mData.addAll(list)      if (force) {        mAdapter1.notifyDataSetChanged()        mAdapter2.notifyDataSetChanged()      }    }    setNewInstance(list)    scrollToLast()  }  fun addConfig(config: ParallaxViewConfig): ParallaxView {    mConfig = config    return this  }  fun build() {    orientation = VERTICAL    isMotionEventSplittingEnabled = false    mScrollListeners[0] = object : RecyclerView.OnScrollListener() {      override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {        super.onScrolled(recyclerView, dx, dy)        if (isLoop.not()) {          mScrollListeners[1]?.let { mRv2.removeOnScrollListener(it) }          mRv2.scrollBy(dx, dy)          mScrollListeners[1]?.let { mRv2.addOnScrollListener(it) }        }      }    }    mScrollListeners[1] = object : RecyclerView.OnScrollListener() {      override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {        super.onScrolled(recyclerView, dx, dy)        if (isLoop.not()) {          mScrollListeners[0]?.let { mRv1.removeOnScrollListener(it) }          mRv1.scrollBy(dx, dy)          mScrollListeners[0]?.let { mRv1.addOnScrollListener(it) }        }      }    }    addView(mRv1)    addView(mRv2)  }  fun reverseLoop() {    stop()    mConfig.direction = when (mConfig.direction) {      ParallaxDirection.Forward -> ParallaxDirection.Backward      ParallaxDirection.Backward -> ParallaxDirection.Forward    }    start()  }  private fun scrollToLast() {    post {      val offsetPos = mData.size * (MAX_COUNT / 2)      (mRv1.layoutManager as? LinearLayoutManager)        ?.scrollToPositionWithOffset(offsetPos, mConfig.offsetFirst)      (mRv2.layoutManager as? LinearLayoutManager)        ?.scrollToPositionWithOffset(offsetPos, mConfig.offsetSecond)      if (mConfig.autoLoop) start()    }  }  /******====== 滑动处理 ======******/  private fun snapToNext() {    mRv1.smoothScrollBy(      SCROLL_DISTANCE * mConfig.direction.value,      0,      mInterpolator,      SCROLL_TIME    )    mRv2.smoothScrollBy(      SCROLL_DISTANCE *        if (mConfig.reverse) (-1) * mConfig.direction.value        else mConfig.direction.value,      0,      mInterpolator,      SCROLL_TIME    )  }  fun start() {    if (mConfig.autoLoop && isLoop.not()) {      stop()      isLoop = true      post(mLoopTask)    }  }  fun stop() {    if (mConfig.autoLoop && isLoop) {      isLoop = false      removeCallbacks(mLoopTask)    }  }  override fun onWindowFocusChanged(hasWindowFocus: Boolean) {    super.onWindowFocusChanged(hasWindowFocus)    if (hasWindowFocus) {      start()    } else stop()  }  override fun onAttachedToWindow() {    super.onAttachedToWindow()    start()  }  override fun onDetachedFromWindow() {    super.onDetachedFromWindow()    stop()  }  override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {    when (event) {      Lifecycle.Event.ON_RESUME,      Lifecycle.Event.ON_START -> start()      Lifecycle.Event.ON_STOP,      Lifecycle.Event.ON_PAUSE,      Lifecycle.Event.ON_DESTROY -> stop()      else -> Unit    }  }  override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {    ev?.actionMasked?.let {      if (it == MotionEvent.ACTION_UP        || it == MotionEvent.ACTION_CANCEL        || it == MotionEvent.ACTION_OUTSIDE      ) {        start()      } else if (it == MotionEvent.ACTION_DOWN) {        stop()      }      return super.dispatchTouchEvent(ev)    } ?: return false  }  /******====== Tools ======******/  class AutoLoopTask(banner: ParallaxView) : Runnable {    private val mBanner: WeakReference<ParallaxView> = WeakReference<ParallaxView>(banner)    override fun run() {      mBanner.get()?.let { banner ->        banner.snapToNext()        banner.postDelayed(banner.mLoopTask, LOOP_TIME)      }    }  }}